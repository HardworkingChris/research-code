#!/usr/bin/env python

'''
Note on working with PulsePackets:
    If a spike generated by a pulse packet gets shifted too far back,
    it may get shifted beyond t=0 (negative time), which is not allowed.
    The most straightfoward way to deal with this is running the simulation
    with 0 input for some time before inserting spikes and simply ignoring
    the start (spikes -= quiet time).
'''

from brian import *
from IPython import embed


duration = 10000*ms
N_nrns = 10
lif_eq = ['dV/dt = (-V+V_rest)/tau_mem : volt']
V_rest = 0*mV
V_reset = 0*mV
V_th = 15*mV
t_refr = 2*ms
tau_mem = 10*msecond
N_in = 10
f_in = 10*Hz
V_inp = 1.0*mV
pulse_times = [1*second,2*second,3*second,4*second,5*second,6*second,7*second]
N_in = 1000
sigma_in = 100*ms
nrns = NeuronGroup(N_nrns,lif_eq,threshold=V_th,reset=V_reset,refractory=t_refr)
input_spikes = []
for st in pulse_times:
    input_spikes.extend(PulsePacket(t=st,n=N_in,sigma=sigma_in).spiketimes)
inp = SpikeGeneratorGroup(N_in, input_spikes)
con = Connection(inp, nrns, 'V')
con.connect_random(inp, nrns, p=0.3, weight=1.0*mV)
mem_mon = StateMonitor(nrns,'V',record=True)
inp_mon = SpikeMonitor(inp)
out_mon = SpikeMonitor(nrns)
run(duration,report='stdout')

#subplot(2,1,1)
#raster_plot(inp_mon)
#subplot(2,1,2)
#plot(mem_mon.times,mem_mon[0])
spikes = array([])
for n in inp_mon.getspiketimes():
    spikes = append(spikes, inp_mon.spiketimes[n])
embed() # drop to ipython shell


